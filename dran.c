#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define NP 14
#define M 16384      /* (int)(pow(2,NP)) */
#define IP 250
#define IQ 250-103
#define NBIT 30
#define NP1 (NBIT-NP)
#define NN1 65536    /* (int)(pow(2,NP1)) */
#define NN NN1-1

#define C0 2.515517
#define C1 0.802853
#define C2 0.010328
#define D1 1.432788
#define D2 0.189269
#define D3 0.001308

#define PI1 4.*atan(1.)
#define MAXINT2 1073741823     /* (int)(pow(2,NBIT))-1 */
#define NMAX 50000000

unsigned int *ix;
double *g;

int dran_ini();
void dran_gv();
double ran1();

/*        
     Gaussian generator initialiser
*/

int dran_ini(iseed,n)
   int iseed,n;
{
   int i;
   double p,t,x,u2th;

   g=(double *)calloc(M+1,sizeof(double)); 
   ix=(unsigned int *)calloc(NMAX+IP,sizeof(unsigned int));         

   if (n>NMAX)
   {
       printf("Not enough random numbers for this system size!\n");
       printf("Exiting\n");
       return 1;
   }

   for (i=0;i<IP;i++)
   {
      ix[i]=ran1(&iseed)*MAXINT2;
   }

   for (i=M/2;i<M+1;i++)
   {
      p=(double)(i+1)/(double)(M+2);
      t=sqrt(-2.0*log(1.-p));
      x=t-(C0+t*(C1+C2*t))/(1.+t*(D1+t*(D2+t*D3)));
      g[i]=x;
      g[M-i]=-x;
   }
/*
   printf("\nCut-off value = %f\n",g[M]);
*/

   u2th=1.0-(double)(M+2)/M*sqrt(2.0/PI1)*g[M]*exp(-g[M]*g[M]/2.);
   u2th=NN1*sqrt(u2th);

   for (i=0;i<M+1;i++)
   {
      g[i]=g[i]/u2th;
   }

   return 0;
}


/*        
     Gaussian generator
*/

void dran_gv(double *rn,int n)
{ 
   int i,k;
   unsigned int ir,i2;
   double rnn,gn,ixn;

   for (k=0;k<n;k++)
   {
      ir=ix[k+IQ]^ix[k];
      i=ir>>NP1;
      i2=ir&NN;

      rn[k]=i2*g[i+1]+(NN1-i2)*g[i];
      ix[k+IP]=ir;
   }

   for (i=0;i<IP;i++)
   {
      ix[i]=ix[i+n];
   }

   return;
}

#define M1 259200
#define IA1 7141
#define IC1 54773
#define RM1 (1.0/M1)
#define M2 134456
#define IA2 8121
#define IC2 28411
#define RM2 (1.0/M2)
#define M3 243000
#define IA3 4561
#define IC3 51349


double ran1(idum)
int *idum;
/* Returns a uniform deviate between 0.0 and 1.0.  Set idum to any negative
value to initialize of reinitialize the sequence.  */
{
   static long ix1, ix2, ix3;
   static float r[98];
   double temp;
   static int iff=0;
   int j;
   
   if (*idum < 0 || iff == 0) 		 /* Initialize on first call even */
   {					 /* if idum is not negative. */
      iff = 1;
      ix1 = (IC1 - (*idum)) % M1;	 /* Seed the first routine, */
      ix1 = (IA1 * ix1 + IC1) % M1;
      ix2 = ix1 % M2;			 /* and use it to seed the second */
      ix1 = (IA1 * ix1 + IC1) % M1;
      ix3 = ix1 % M3;			 /* and third routines. */

      for (j = 1; j <= 97; j++) 	 /* Fill the table with sequential */
      {					 /* uniform deviates generated by */
         ix1 = (IA1 * ix1 + IC1) % M1;	 /* the first two routines. */
         ix2 = (IA2 * ix2 + IC2) % M2;
         r[j] = (ix1 + ix2 * RM2) * RM1; /* Low- and high-order pieces */ 
      }					 /* combined here. */
      *idum = 1;
   }
   ix1 = (IA1 * ix1 + IC1) % M1;	/* Except when initializing, this */
   ix2 =  (IA2 * ix2 + IC2) % M2;	/* is where we start.  Generate */ 
   ix3 = ( IA3 * ix3 + IC3) % M3;       /* the next number for each sequence.*/
   j = 1 + ((97 * ix3)/M3);		/* Use the third sequence to get an */
   if (j > 97 || j < 1) 		/* integer between 1 and 97 */
   {
      printf("Error In ran1 routine.\n");
      exit(-1);
   }
   temp = r[j];				/* Return that table entry, */
   r[j] = (ix1 + ix3 * RM2) * RM1;  	/* and refill it. */
   return temp;
}
